using System;

namespace Jurassic.Compiler
{
    /// <summary>
    /// Represents the unit of compilation.
    /// </summary>
    internal abstract class ScriptContext
    {
        /// <summary>
        /// Creates a new ScriptContext instance.
        /// </summary>
        /// <param name="scope"> The initial scope. </param>
        /// <param name="scriptPath"> The URL or file system path that the script was sourced from. </param>
        protected ScriptContext(Scope scope, string scriptPath)
        {
            if (scope == null)
                throw new ArgumentNullException("scope");
            this.InitialScope = scope;
            this.Path = scriptPath;
        }

        /// <summary>
        /// Gets or sets a value that indicates whether the context is operating in ECMAScript 5
        /// strict mode.
        /// </summary>
        public bool StrictMode
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the top-level scope associated with the context.
        /// </summary>
        public Scope InitialScope
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the URL or file system path that the script was sourced from.
        /// </summary>
        public string Path
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the root node of the abstract syntax tree.  This will be <c>null</c> until Parse()
        /// is called.
        /// </summary>
        public Statement AbstractSyntaxTree
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the emitted dynamic method.  This will be <c>null</c> until GenerateCode() is
        /// called.
        /// </summary>
        public System.Reflection.Emit.DynamicMethod DynamicMethod
        {
            get;
            protected set;
        }

        /// <summary>
        /// Gets the generated IL.  This will be <c>null</c> until GenerateCode() is
        /// called.
        /// </summary>
        public ILGenerator ILGenerator
        {
            get;
            protected set;
        }

        /// <summary>
        /// Gets a delegate to the emitted dynamic method.  This will be <c>null</c> until
        /// Execute() is called.
        /// </summary>
        public Delegate CompiledDelegate
        {
            get;
            protected set;
        }

        /// <summary>
        /// Parses the source text into an abstract syntax tree.
        /// </summary>
        public void Parse()
        {
            this.AbstractSyntaxTree = ParseCore();
        }

        /// <summary>
        /// Parses the source text into an abstract syntax tree.
        /// </summary>
        /// <returns> The root node of the abstract syntax tree. </returns>
        protected abstract Statement ParseCore();

        /// <summary>
        /// Optimizes the abstract syntax tree.
        /// </summary>
        public void Optimize()
        {
            // Generate the abstract syntax tree if it hasn't already been generated.
            //if (this.AbstractSyntaxTree == null)
            //    Parse();
            //this.AbstractSyntaxTree.Optimize();
        }

        /// <summary>
        /// Gets an array of types - one for each parameter accepted by the method generated by
        /// this context.
        /// </summary>
        /// <returns> An array of parameter types. </returns>
        protected virtual Type[] GetParameterTypes()
        {
            return new Type[] {
                typeof(Scope),          // The scope.
                typeof(object),         // The "this" object.
            };
        }

        /// <summary>
        /// Generates IL for the script.
        /// </summary>
        public void GenerateCode()
        {
            // Generate the abstract syntax tree if it hasn't already been generated.
            if (this.AbstractSyntaxTree == null)
            {
                Parse();
                Optimize();
            }

//#if !DEBUG
            // Create a new dynamic method.
            this.DynamicMethod = new System.Reflection.Emit.DynamicMethod(
                "Main",                                                 // Name of the generated method.
                typeof(object),                                         // Return type of the generated method.
                GetParameterTypes(),                                    // Parameter types of the generated method.
                typeof(ScriptContext),                                  // Owner type.
                true);                                                  // Skip visibility checks.

            // Generate the IL.
            var generator = new DynamicILGenerator(this.DynamicMethod);
            GenerateCode(generator);
            generator.Complete();

            // Create a delegate from the method.
            this.CompiledDelegate = this.DynamicMethod.CreateDelegate(GetDelegate());

//#else

//            var filePath = System.IO.Path.Combine(System.IO.Path.GetTempPath(), "JurassicDebug.dll");

//            // Create a dynamic assembly and module.
//            var assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(new System.Reflection.AssemblyName("Debug"),
//                System.Reflection.Emit.AssemblyBuilderAccess.Save, System.IO.Path.GetDirectoryName(filePath), false, null);

//            // Mark the assembly as debuggable.
//            var debuggableAttributeConstructor = typeof(System.Diagnostics.DebuggableAttribute).GetConstructor(
//                new Type[] { typeof(System.Diagnostics.DebuggableAttribute.DebuggingModes) });
//            assemblyBuilder.SetCustomAttribute(new System.Reflection.Emit.CustomAttributeBuilder(debuggableAttributeConstructor, new object[] { 
//                System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations | 
//                System.Diagnostics.DebuggableAttribute.DebuggingModes.Default }));

//            // Create a dynamic module.
//            var module = assemblyBuilder.DefineDynamicModule("Module", System.IO.Path.GetFileName(filePath));

//            // Create a new type to hold our method.
//            var typeBuilder = module.DefineType("JavaScriptClass", System.Reflection.TypeAttributes.Public | System.Reflection.TypeAttributes.Class);

//            // Create a method.
//            var methodBuilder = typeBuilder.DefineMethod("Main", System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.Public,
//                typeof(object), GetParameterTypes());

//            // Generate the IL for the method.
//            var generator = new ReflectionEmitILGenerator(methodBuilder);
//            GenerateCode(generator);
//            generator.Complete();

//            // Bake it.
//            var type = typeBuilder.CreateType();
//            var method = type.GetMethod("Main");

//            // Disassemble the IL.
//            var reader = new ClrTest.Reflection.ILReader(method);
//            var writer = new System.IO.StringWriter();
//            var visitor = new ClrTest.Reflection.ReadableILStringVisitor(new ClrTest.Reflection.ReadableILStringToTextWriter(writer));
//            reader.Accept(visitor);
//            string il = writer.ToString();

//            // set the entry point for the application and save it
//            assemblyBuilder.Save(System.IO.Path.GetFileName(filePath));

//            // Copy this DLL there as well.
//            var assemblyPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
//            System.IO.File.Copy(assemblyPath, System.IO.Path.Combine(System.IO.Path.GetDirectoryName(filePath), System.IO.Path.GetFileName(assemblyPath)), true);

//            var startInfo = new System.Diagnostics.ProcessStartInfo();
//            startInfo.FileName = @"C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Bin\NETFX 4.0 Tools\x64\PEVerify.exe";
//            startInfo.Arguments = string.Format("\"{0}\" /nologo /verbose /unique", filePath);
//            startInfo.CreateNoWindow = true;
//            startInfo.RedirectStandardOutput = true;
//            startInfo.UseShellExecute = false;
//            var verifyProcess = System.Diagnostics.Process.Start(startInfo);
//            string output = verifyProcess.StandardOutput.ReadToEnd();

//            if (verifyProcess.ExitCode != 0)
//            {
//                throw new InvalidOperationException(output);
//            }
//            else
//            {
//                //System.Diagnostics.Process.Start(@"C:\Program Files\Reflector\Reflector.exe", string.Format("\"{0}\" /select:JavaScriptClass", filePath));
//                //Environment.Exit(0);
//            }

//            this.CompiledDelegate = Delegate.CreateDelegate(GetDelegate(), method);
//#endif
        }

        /// <summary>
        /// Generates IL for the script.
        /// </summary>
        /// <param name="generator"> The generator to output the CIL to. </param>
        protected abstract void GenerateCode(ILGenerator generator);

        /// <summary>
        /// Retrieves a delegate for the generated method.
        /// </summary>
        /// <param name="types"> The parameter types. </param>
        /// <returns> The delegate type that matches the method parameters. </returns>
        protected virtual Type GetDelegate()
        {
            var types = GetParameterTypes();
            Array.Resize(ref types, types.Length + 1);
            types[types.Length - 1] = typeof(object);
            switch (types.Length)
            {
                case 1:
                    return typeof(Func<>).MakeGenericType(types);

                case 2:
                    return typeof(Func<,>).MakeGenericType(types);

                case 3:
                    return typeof(Func<,,>).MakeGenericType(types);

                case 4:
                    return typeof(Func<,,,>).MakeGenericType(types);

                case 5:
                    return typeof(Func<,,,,>).MakeGenericType(types);

                case 6:
                    return typeof(Func<,,,,,>).MakeGenericType(types);

                case 7:
                    return typeof(Func<,,,,,,>).MakeGenericType(types);

                case 8:
                    return typeof(Func<,,,,,,,>).MakeGenericType(types);

                case 9:
                    return typeof(Func<,,,,,,,,>).MakeGenericType(types);

                case 10:
                    return typeof(Func<,,,,,,,,,>).MakeGenericType(types);

                case 11:
                    return typeof(Func<,,,,,,,,,,>).MakeGenericType(types);

                case 12:
                    return typeof(Func<,,,,,,,,,,,>).MakeGenericType(types);

                case 13:
                    return typeof(Func<,,,,,,,,,,,,>).MakeGenericType(types);

                case 14:
                    return typeof(Func<,,,,,,,,,,,,,>).MakeGenericType(types);

                case 15:
                    return typeof(Func<,,,,,,,,,,,,,,>).MakeGenericType(types);

                case 16:
                    return typeof(Func<,,,,,,,,,,,,,,,>).MakeGenericType(types);

                case 17:
                    return typeof(Func<,,,,,,,,,,,,,,,,>).MakeGenericType(types);
            }
            throw new InvalidOperationException("Too many arguments.");
        }
    }

}