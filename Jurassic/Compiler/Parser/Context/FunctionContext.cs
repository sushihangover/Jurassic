using System;
using System.Collections.Generic;

namespace Jurassic.Compiler
{
    /// <summary>
    /// Represents the information needed to compile a function.
    /// </summary>
    internal class FunctionContext : ScriptContext
    {
        /// <summary>
        /// Creates a new FunctionContext instance.
        /// </summary>
        /// <param name="scope"> The function scope. </param>
        /// <param name="name"> The name of the function. </param>
        /// <param name="argumentNames"> The names of the arguments. </param>
        /// <param name="body"> The root of the abstract syntax tree for the body of the function. </param>
        /// <param name="scriptPath"> The URL or file system path that the script was sourced from. </param>
        public FunctionContext(Scope scope, string functionName, IList<string> argumentNames, Statement body, string scriptPath)
            : base(scope, scriptPath)
        {
            this.Name = functionName;
            this.ArgumentNames = argumentNames;
            this.BodyRoot = body;
        }

        /// <summary>
        /// Creates a new FunctionContext instance.
        /// </summary>
        /// <param name="scope"> The function scope. </param>
        /// <param name="name"> The name of the function. </param>
        /// <param name="argumentNames"> The names of the arguments. </param>
        /// <param name="body"> The source code for the body of the function. </param>
        /// <param name="scriptPath"> The URL or file system path that the script was sourced from. </param>
        public FunctionContext(Scope scope, string functionName, IList<string> argumentNames, string body, string scriptPath)
            : base(scope, scriptPath)
        {
            this.Name = functionName;
            this.ArgumentNames = argumentNames;
            this.BodyText = body;
        }

        /// <summary>
        /// Gets the name of the function.
        /// </summary>
        public string Name
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets a list of argument names.
        /// </summary>
        public IList<string> ArgumentNames
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the root of the abstract syntax tree for the body of the function.
        /// </summary>
        public Statement BodyRoot
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the source code for the body of the function.
        /// </summary>
        public string BodyText
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets or sets function optimization information.
        /// </summary>
        public FunctionOptimizationInfo Optimizations
        {
            get;
            set;
        }

        /// <summary>
        /// Parses the source text into an abstract syntax tree.
        /// </summary>
        /// <returns> The root node of the abstract syntax tree. </returns>
        protected override Statement ParseCore()
        {
            if (this.BodyRoot != null)
                return this.BodyRoot;
            var lexer = new Lexer(new System.IO.StringReader(this.BodyText), this.Path);
            var parser = new Parser(lexer, this.InitialScope, true);
            var result = parser.Parse();
            this.StrictMode = parser.StrictMode;
            return result;
        }

        /// <summary>
        /// Gets an array of types - one for each parameter accepted by the method generated by
        /// this context.
        /// </summary>
        /// <returns> An array of parameter types. </returns>
        protected override Type[] GetParameterTypes()
        {
            return new Type[] {
                typeof(Scope),                      // The parent scope.
                typeof(object),                     // The "this" object.
                typeof(Library.FunctionInstance),   // The function object.
                typeof(object[])                    // The argument values.
            };
        }

        /// <summary>
        /// Retrieves a delegate for the generated method.
        /// </summary>
        /// <param name="types"> The parameter types. </param>
        /// <returns> The delegate type that matches the method parameters. </returns>
        protected override Type GetDelegate()
        {
            return typeof(Library.FunctionDelegate);
        }

        /// <summary>
        /// Generates IL for the script.
        /// </summary>
        /// <param name="generator"> The generator to output the CIL to. </param>
        protected override void GenerateCode(ILGenerator generator)
        {
            // Method signature: object FunctionDelegate(Compiler.Scope scope, object thisObject, Library.FunctionInstance functionObject, object[] arguments)

            // Store the state of the StrictMode flag in the optimization info instance.
            var optimizationInfo = OptimizationInfo.Empty;
            if (this.StrictMode == true)
                optimizationInfo = optimizationInfo.AddFlags(OptimizationFlags.StrictMode);

            // Create a new scope.
            this.InitialScope.GenerateScopeCreation(generator, optimizationInfo);

            // In ES3 the "this" value must be an object.  See 10.4.3 in the spec.
            if (this.StrictMode == false)
            {
                // if (thisObject == null || thisObject == Null.Value || thisObject == Undefined.Value)
                generator.LoadArgument(1);
                generator.LoadNull();
                generator.Equal();
                generator.LoadArgument(1);
                EmitHelpers.EmitNull(generator);
                generator.Equal();
                generator.BitwiseOr();
                generator.LoadArgument(1);
                EmitHelpers.EmitUndefined(generator);
                generator.Equal();
                generator.BitwiseOr();

                // {
                var startOfFalse = generator.CreateLabel();
                generator.BranchIfFalse(startOfFalse);

                // thisObject = GlobalObject.Instance;
                generator.Call(ReflectionHelpers.Global_Instance);
                
                // } else {
                var endOfIf = generator.CreateLabel();
                generator.Branch(endOfIf);
                generator.DefineLabelPosition(startOfFalse);
                
                // thisObject = TypeConverter.ToObject(thisObject);
                generator.LoadArgument(1);
                EmitConversion.ToObject(generator, PrimitiveType.Any);

                // }
                generator.DefineLabelPosition(endOfIf);
                generator.StoreArgument(1);
            }

            // Transfer the function name into the scope.
            if (string.IsNullOrEmpty(this.Name) == false)
            {
                generator.LoadArgument(2);
                var functionName = new NameExpression(this.InitialScope, this.Name);
                functionName.GenerateSet(generator, optimizationInfo, PrimitiveType.Any, false);
            }

            // Transfer the arguments object into the scope.
            if (this.Optimizations != null && this.Optimizations.HasArguments == true)
            {
                // prototype
                generator.Call(ReflectionHelpers.Global_Object);
                generator.Call(ReflectionHelpers.FunctionInstance_InstancePrototype);
                // callee
                generator.LoadArgument(2);
                generator.CastClass(typeof(Library.UserDefinedFunction));
                // scope
                generator.LoadArgument(0);
                generator.CastClass(typeof(DeclarativeScope));
                // argumentValues
                generator.LoadArgument(3);
                generator.NewObject(ReflectionHelpers.Arguments_Constructor);
                var arguments = new NameExpression(this.InitialScope, "arguments");
                arguments.GenerateSet(generator, optimizationInfo, PrimitiveType.Any, false);
            }

            // Transfer the argument values into the scope.
            // Note: the arguments array can be smaller than expected.
            var endOfArguments = generator.CreateLabel();
            for (int i = 0; i < this.ArgumentNames.Count; i ++)
            {
                // Check if an array element exists.
                generator.LoadArgument(3);
                generator.LoadArrayLength();
                generator.LoadInt32(i);
                generator.BranchIfLessThanOrEqual(endOfArguments);

                // Store the array element in the scope.
                generator.LoadArgument(3);
                generator.LoadInt32(i);
                generator.LoadArrayElement(typeof(object));
                var argument = new NameExpression(this.InitialScope, this.ArgumentNames[i]);
                argument.GenerateSet(generator, optimizationInfo, PrimitiveType.Any, false);
            }
            generator.DefineLabelPosition(endOfArguments);

            // Initialize any declarations.
            this.InitialScope.GenerateDeclarations(generator, optimizationInfo);

            //generator.LoadArgument(0);
            //EmitConversion.ToObject(generator, PrimitiveType.Any);
            //generator.Pop();

            // Generate code for the body of the function.
            this.AbstractSyntaxTree.GenerateCode(generator, optimizationInfo);

            // Return undefined if control gets to the end of the function.
            EmitHelpers.EmitUndefined(generator);
        }

        /// <summary>
        /// Converts this object to a string.
        /// </summary>
        /// <returns> A string representing this object. </returns>
        public override string ToString()
        {
            if (this.BodyRoot != null)
                return string.Format("function {0}({1}) {2}", this.Name, string.Join(", ", this.ArgumentNames), this.BodyRoot);
            return string.Format("function {0}({1}) {{\n{2}\n}}", this.Name, string.Join(", ", this.ArgumentNames), this.BodyText);
        }
    }

}